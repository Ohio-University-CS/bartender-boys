<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Client Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            border: 1px solid #ccc;
            padding: 20px;
            margin: 10px 0;
            border-radius: 5px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        video {
            width: 100%;
            max-width: 400px;
            border: 1px solid #ccc;
            margin: 10px 0;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .peers-list {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>WebRTC Client Example</h1>
    
    <div class="container">
        <h3>Connection Settings</h3>
        <label for="roomId">Room ID:</label>
        <input type="text" id="roomId" value="room1" placeholder="Enter room ID">
        <br><br>
        <label for="peerId">Peer ID:</label>
        <input type="text" id="peerId" value="peer1" placeholder="Enter peer ID">
        <br><br>
        <button id="connectBtn" onclick="connect()">Connect</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>

    <div class="container">
        <h3>Status</h3>
        <div id="status" class="status disconnected">Disconnected</div>
        <div id="peersList" class="peers-list" style="display: none;">
            <strong>Peers in room:</strong>
            <ul id="peers"></ul>
        </div>
    </div>

    <div class="container">
        <h3>Video</h3>
        <video id="localVideo" autoplay muted></video>
        <video id="remoteVideo" autoplay></video>
        <br>
        <button id="startVideoBtn" onclick="startVideo()" disabled>Start Video</button>
        <button id="stopVideoBtn" onclick="stopVideo()" disabled>Stop Video</button>
    </div>

    <script>
        // Configuration
        const WS_URL = 'ws://localhost:8000/webrtc/signaling';
        
        // Global variables
        let websocket = null;
        let localPeerConnection = null;
        let localStream = null;
        let roomId = '';
        let peerId = '';
        
        // STUN servers for NAT traversal
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        function updateStatus(message, isConnected = false) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${isConnected ? 'connected' : 'disconnected'}`;
        }

        function updatePeersList(peers) {
            const peersListEl = document.getElementById('peersList');
            const peersEl = document.getElementById('peers');
            
            if (peers.length === 0) {
                peersListEl.style.display = 'none';
                return;
            }
            
            peersListEl.style.display = 'block';
            peersEl.innerHTML = peers.map(peer => `<li>${peer}</li>`).join('');
        }

        function connect() {
            roomId = document.getElementById('roomId').value;
            peerId = document.getElementById('peerId').value;
            
            if (!roomId || !peerId) {
                alert('Please enter both Room ID and Peer ID');
                return;
            }
            
            const wsUrl = `${WS_URL}/${roomId}/${peerId}`;
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = function() {
                updateStatus(`Connected to room: ${roomId}`, true);
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                document.getElementById('startVideoBtn').disabled = false;
            };
            
            websocket.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleSignalingMessage(message);
            };
            
            websocket.onclose = function() {
                updateStatus('Disconnected', false);
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                document.getElementById('startVideoBtn').disabled = true;
                document.getElementById('stopVideoBtn').disabled = true;
                updatePeersList([]);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateStatus('Connection error', false);
            };
        }

        function disconnect() {
            if (websocket) {
                websocket.close();
            }
            if (localPeerConnection) {
                localPeerConnection.close();
                localPeerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
        }

        function handleSignalingMessage(message) {
            switch (message.type) {
                case 'existing_peers':
                    updatePeersList(message.peers);
                    break;
                case 'peer_joined':
                    updatePeersList([...document.getElementById('peers').children.map(li => li.textContent), message.peer_id]);
                    break;
                case 'peer_left':
                    const currentPeers = document.getElementById('peers').children;
                    const updatedPeers = Array.from(currentPeers)
                        .map(li => li.textContent)
                        .filter(peer => peer !== message.peer_id);
                    updatePeersList(updatedPeers);
                    break;
                case 'offer':
                    handleOffer(message.offer, message.from_peer_id);
                    break;
                case 'answer':
                    handleAnswer(message.answer, message.from_peer_id);
                    break;
                case 'ice_candidate':
                    handleIceCandidate(message.candidate, message.from_peer_id);
                    break;
            }
        }

        async function startVideo() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('startVideoBtn').disabled = true;
                document.getElementById('stopVideoBtn').disabled = false;
                
                // Create peer connection for each existing peer
                const existingPeers = Array.from(document.getElementById('peers').children)
                    .map(li => li.textContent);
                
                for (const existingPeer of existingPeers) {
                    await createPeerConnection(existingPeer);
                }
                
            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Error accessing camera/microphone. Please check permissions.');
            }
        }

        function stopVideo() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('startVideoBtn').disabled = false;
            document.getElementById('stopVideoBtn').disabled = true;
            
            if (localPeerConnection) {
                localPeerConnection.close();
                localPeerConnection = null;
            }
        }

        async function createPeerConnection(targetPeerId) {
            localPeerConnection = new RTCPeerConnection(iceServers);
            
            // Add local stream to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    localPeerConnection.addTrack(track, localStream);
                });
            }
            
            // Handle incoming remote stream
            localPeerConnection.ontrack = function(event) {
                document.getElementById('remoteVideo').srcObject = event.streams[0];
            };
            
            // Handle ICE candidates
            localPeerConnection.onicecandidate = function(event) {
                if (event.candidate) {
                    sendSignalingMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate,
                        target_peer_id: targetPeerId
                    });
                }
            };
            
            // Create and send offer
            const offer = await localPeerConnection.createOffer();
            await localPeerConnection.setLocalDescription(offer);
            
            sendSignalingMessage({
                type: 'offer',
                offer: offer,
                target_peer_id: targetPeerId
            });
        }

        async function handleOffer(offer, fromPeerId) {
            if (!localPeerConnection) {
                localPeerConnection = new RTCPeerConnection(iceServers);
                
                // Add local stream to peer connection
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        localPeerConnection.addTrack(track, localStream);
                    });
                }
                
                // Handle incoming remote stream
                localPeerConnection.ontrack = function(event) {
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                };
                
                // Handle ICE candidates
                localPeerConnection.onicecandidate = function(event) {
                    if (event.candidate) {
                        sendSignalingMessage({
                            type: 'ice_candidate',
                            candidate: event.candidate,
                            target_peer_id: fromPeerId
                        });
                    }
                };
            }
            
            await localPeerConnection.setRemoteDescription(offer);
            const answer = await localPeerConnection.createAnswer();
            await localPeerConnection.setLocalDescription(answer);
            
            sendSignalingMessage({
                type: 'answer',
                answer: answer,
                target_peer_id: fromPeerId
            });
        }

        async function handleAnswer(answer, fromPeerId) {
            if (localPeerConnection) {
                await localPeerConnection.setRemoteDescription(answer);
            }
        }

        async function handleIceCandidate(candidate, fromPeerId) {
            if (localPeerConnection) {
                await localPeerConnection.addIceCandidate(candidate);
            }
        }

        function sendSignalingMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
            }
        }
    </script>
</body>
</html>
